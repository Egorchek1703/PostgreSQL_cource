***Очиста и оптимизация работы PostgreSQL***  
  
**==================> Действия необходимые для поддержания работоспособности PostgreSQL <==================**  
  
1. Очистка страниц "мёртвых" версий (тех версий, которые не видны ни в одном снимке (все транзакции, работающие с ними - закрыты, и сами строки уже были обновлены))  
2. Очистка индексов ссылающихся на "мёртвые" версии (индексы храняться в отдельной таблице в виде пары значений: index (номер строки и страницы таблицы с данными) - значение индексируемого поля)  
3. Обновление карты видимости (специальная информация - битовая карта в которой отмечены все страницы, на которых все версии строк видны на всех существующих снимках, т.е. у строки нет "мёртвых" версий. Благодаря этой карте процесс очистки знает к каким страницам не нужно обращаться при осуществлении чистки, соответственно, это благоприятно влияет на производительность) + (когда мы читаем только индексные столбцы, то зачастую нам не нужно ходить в саму таблицу данных, т.к. мы можем получить все данные из сбалансированного B-дерева индексов. В дереве индексов мы не обладаем информацией о версионности, поэтому необходимо в любом случае идти в таблицу в которой храняться сами данные, чтобы узнать ссылается ли индекс на актуальную строку (в таком случае теряется смысл в использовании индексов). В таком случае карта видимости также может помочь нам, ведь мы можем найти по индексу данную строку внутри карты видимости и узнать является ли данная строка данных видимой во всех снимках (не мёртвой), а значит нам не нужно искать саму строку в таблице с данными.) 
4. Обновление карты свободного пространства (отмечает свободное место в страницах) - поддерживание в актуальном состоянии позволяет быстро выполнить процесс поиска свободного места в файлах данных, что также оптимизирует процесс записи строки или ее новой версии.  
5. Обновление статистики планировщика запросов (в данном случае поддержание актуальной информации важно, например, в следующем случае: планировщик опираясь на статистику формирует план запроса. Следовательно, если в статистике отражено кол-во строк 10, а реальной их кол-во 10 млн., то планировщик может решить что запрос простой и на основании этого выполнить данный запрос неэффективно.) *В PostgreSQL статистика обновляется автоматически с помощью процесса анализа (например, с помощью команды ANALYZE), но в некоторых случаях может потребоваться ручное обновление статистики, чтобы избежать таких проблем. Команда ANALYZE собирает статистику о таблицах и индексах, что помогает планировщику принимать более обоснованные решения.*  
6. Выполнение заморозки (Под номер транзакции выделено всего 32 бита, поэтому txid ограничен примерно 4 млрд. значений. Операция заморозки находит те транзакции у которых txid в ближайшее время может повториться и заменять число (txid) на определенный символ заморозки, а следовательно, мы можем повторно использовать номера которые были сняты с старых транзакций. Если бы процесс замарозки не работал, то рано или поздно пришел бы тот момент, когда 2 транзакции имеют один номер. В таком случае сервер выполняет аварийную остановку)  
  
**Данные мероприятия необходимо выполнять регулярно. К счастью, есть специльный процесс, выполняющий их все автоматически**  
  
Данный процесс называется **"Autovacuum launcher"**. Он висит в системе и периодически запускает рабочие процессы для определенных БД. Такие рабочие процессы называются **"Autovacuum worker"**. Данный процесс подключается к определенной базе, смотрит какие таблицы необходимо очистить от старых версий, каким таблицам необходимо обновить статистику, какие карты необходимо обновить и выполняет все необходимые мероприятия.  
  
*В некоторых случаях данные процессы необходимо запускать вручную. Для того чтобы вручную не приходилось запускать процессы слишком часто необходимо уметь настраивать процесс Autovacuum launcher с помощью конфигурационных параметров*  
  
Для ручного запуска очистки необходимо выполнить:  
1. В psql:  
```
    VACUUM - при очистке всей БД  
    VACUUM \[таблица_1, таблица_2\] - для очистки отдельных таблиц  
```  
2. vacuumdb - для запуска очистки с хоста  
  
Для ручного запуска сбора статистики и анализа:  
1. В psql:  
```
    ANALYZE  
```  
2. 
```
    vacuumdb --analyze-only - для запуска сбора статистики с хоста 
```  
3. Для выполнения как очистки так и сбора статистики:  
```
    VACUUM ANALYZE - для запуска в psql  
```  
```
    vacuumdb --analyze - для запуска с хоста  
```  
  
**Как это работает на примере:**  
  
1. Создадим таблицу без автоматической очистки (чтобы запускать ее вручную):  
```
    CREATE TABLE bloat (
        id integer GENERATED ALWAYS AS IDENTITY,
        d timestamptz
    ) WITH (autovacuum_enabled = off);
```  
2. Вставим в нашу таблицу 100.000 строк с помощью функции generate_series()  
```
    INSERT INTO bloat(d)
    SELECT current_timestamp FROM generate_series(1, 100000);
```  
3. Также создадим индекс по полю d для каждой строки из нашей таблицы:  
```
    CREATE INDEX ON bloat(d);
```  
4. Теперь обновим значение для строки с id = 1:  
```
    UPDATE bloat SET d = d + interval '1 day' 
    WHERE id = 1;
```  
После данных преобразований у нас появилась строка с "мертвой" версией, а следовательно, запуск процесса Autovacuum должен удалить одну версию строки с id = 1  
5. Запустим вручную данный процесс передав в него параметр **verbose** - который выводит подромное описание того, что было сделано процессом:  
```
    VACUUM (verbose) bloat;
```  
  
Вывод команды будет содержать строку **"tuples: 1 removed ..."**, которая означает, что была удалена одна запись (как раз-таки та, запись "мертвой" версии строки с id = 1).  
Также была удалена одна строчка из индекса, ссылающаяся на данную "мертвую" версию, о чем и говорить строка **"1 index row version were removed"**  
  
Когда мы выполняем очистку, файл данных с точки зрения операционной системы не уменьшается. В нем просто появляются свободные строки которые мы можем использовать в дальнейшем, но как и было сказано, памяти занимаемой данный файлом меньше не становиться. Следовательно, при изменении, например, всех записей в нашей таблице произойдет его увеличение в 2 раза. Если есть какие-либо открытые транзакции, работающие с предыдущими снимками (до изменения UPDATE), то процесс Autovacuum не сможет очистить данную таблицу, т.к. будет считать, что "мертвые" версии всех строк в таблице всё еще используются кем-то (т.к. есть снимок содержащий данные версии). Это может привезти к **разрастанию таблиц**.  
  
  
Понять насколько критично разрослись таблицы и пора ли предпринимать какие-то меры, можно разными способами:  
1. Запросами к системному каталогу  
2. Используя расширение pgstattuple  
На данном этапе мы воспользуемся вторым способом. Для того чтобы установить расширение необходимо выполнить:  
```
    CREATE EXTENSION pgstattuple;
```  
Затем нам достаточно выполнить запрос из таблицы с результатом выполнения данной функции и переданным в нее парамертов - названием нашей таблицы с данными, а именно, следующим образом:  
```
    SELECT * FROM pgstattuple('bloat') \gx
```  
В выводе данного расширения нам интересна строка **table_len | 4431872**, показывающая размер таблицы и строка **tuple_percent | 90.26**. Данная строка показывает процентное соотношение соотношение строк с данными ко всему размеру страниц. Не 100 т.к. у страниц есть системные заголовки и подобное.  
Также в данное расширение мы можем засунуть таблицу с индексами:  
```
    SELECT * FROM pgstattuple('bloat_d_idx') \gx
```  
В данном выводе нам также интересна строка **tuple_percent | 85.89**  
  
Теперь, если мы обновим половину данных, то сможем в динамике посмотреть что происходит с таблицами благодаря расширению pgstattuple:
```
    UPDATE bloat SET  d = d + interval '1 day'
    WHERE id % 2 = 0;
```  
*В примере мы обновляем все строки с четными id*  
  
Если мы повторно выполним запросы к таблицам bloat и bloat_d_idx с применением расширения pgstattuple, то получим данные, показывающие что все стало немного хуже:  
Для bloat:  
**tuple_percent | 60.21** - плотность уменьшилась в полтора раза  
**table_len | 6643712** - размер таблицы увеличился также примерно в полтора раза  
Для bloat_d_idx:  
**tuple_percent | 89.66** - плотность практически не изменилась  
**НО**  
**tuple_count | 1123** - кол-во записей также стало в полтора раза больше (прежнее значение 759)  
**table_len | 918112** - размер таблицы стал в полтора раза больше (прежнее значение 612144)  
  
Соответственно теперь, рано или поздно будет выполнена очистка, но т.к. размер файла не уменьшается, то у нас останется раздутый пустой файл, занимающий много места. Чтобы исправить данную проблему необходимо воспользоваться определенными командами.    
**ВАЖНО: данные команды полностью блокируют работу с таблицами, для которых они были активированы**  
```
    VACUUM FULL [название_табилцы] - полностью перестраивает таблицу, избавляясь от пустых строк и лишнего места
    REINDEX INDEX [название_таблицы] - полностью перестраивает таблицу с индексами, также освобождая память (блокирует только записи)
```  
Для выполнения очистки с перестроением таблиц с хоста:  
```
    vacuumdb --full
```  
Важно также понимать, что на нагруженной системе использование таких команд невозможно. Поэтому существует специальное расширение **pgrepack**, которое позволяет преобразовывать таблицы на лету, не блокируя их.  
  
Выполним данные команды для наших таблиц и посмотрим разницу:  
Для bloat:  
```
    VACUUM FULL bloat;
```  
**tuple_percent | 90.26** - плотность вернулась к хорошему значению  
**table_len | 4431872** - размер таблицы вернулся к нормальному значению  
  
Для bloat_d_idx:  
```
    REINDEX INDEX bloat_d_idx;
```  
**tuple_count | 759** - кол-во записей вернулось к нормальному значению  
**table_len | 612144** - размер таблицы также вернулся к нормальному значению  
