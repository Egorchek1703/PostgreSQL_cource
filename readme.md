***Системный каталог***  
  
**==================> Чем представлен системный каталог <==================**  
  
**Системный каталог** - набор таблиц и представлений, описывающий все объекты кластера баз данных.  
  
Внутри каждой базы данных ведётся сбор информации обо всех объектах, принадлежащих текущей базе данных. Данная информация находится в системной схеме pg_catalog внутри БД. Стандарт SQL требует стандартизированное описание объектов системного каталога. PostgreSQL поддерживает данный стандарт. Для этого внутри базы данных находится схема **information_schema**, содержащая представления, которые выполняют запросы к системным таблицам pg_catalog и представляют информацию в том формате, в котором этого требует стандарт SQL. Системная информация в pg_catalog изменяется всякий раз когда мы создаем, удаляем или изменяем объекты текущей базы данных.  
  
Мы можем выполнять запросы к таблицам системного каталога с помощью ключевого слова SELECT внутри терминального окна psql, а можем выполнять более удобные внутренние команды, которые инкапсулируют в себе логику выполнения запросов к системным таблицам и начинаются с **\d**. Часть из них мы уже знаем:
```
    \dn - вывести список схем текущей базы данных
    \dt - вывести список таблиц текущей базы данных
    \dv - вывести список представлений текущей базы данных
```  
*Важно понимать, что не все системные таблицы находятся в pg_catalog. Часть общих объектов кластера, например, таких как таблица pg_database лежат не в системных каталогах. При подключении к любой БД, данные общие объекты кластера видны так, как будто они находятся в pg_catalog, но при этом физически они размещаюстя отдельно (в будующих уроках мы увидим, где именно)*  
  
Разработчики PostgreSQL используются стандартизированный нейминг системных таблиц и их столбцов:
1. Каждая системная таблица начинается с префикса "**pg_**"  
2. Имя каждого столбца в начале включает первые 3 символа названия объекта к которому относится. Т.е. для таблицы pg_**dat**abase, все столбцы будут называться на **dat**. Пример: pg_database.datname.  
  
*Внутри системного каталога названия объектов всегда хранятся в нижнем регистре*

**==================> Важные объекты системного каталога <==================**  
  
Для того чтобы искать информацию о каких-либо объектах в базе данных, нужно чтобы эти объекты были в этой базе данных, поэтому создадим отдельную базу данных и внутри нее таблицу employees, а также представление managers:
```
    CREATE DATABASE example;
    \c example
```  
```
    CREATE TABLE employees(
        id integer GENERATE ALWAYS AS IDENTITY PRIMARY KEY,
        name text,
        manager boolean
    )

    INSERT INTO employees (name, manager) 
    VALUES
        ('Alice', true),
        ('Bob', false),
        ('Charlie', false),
        ('Diana', true),
        ('Eve', false);
```  
```
    CREATE VIEW managers AS 
    SELECT * FROM employees WHERE manager = true;
```  
  
Теперь на основании созданной таблицы и представления, рассмотрим более подробно основные системные объекты внутри системного каталога:  
  
1. **pg_database** - объект системного каталога, содержащий в себе описание всех баз данных в кластере
```
    SELECT * FROM pg_database
    WHERE datname = 'example';
```  
2. **pg_namespace** - объект, содержащий в себе описание схем текущей базы данных  
```
    SELECT * FROM pg_namespace;
```  
3. **pg_class** - важная таблица, в которой хранится описание целого ряда объектов: таблиц, представлений, индексов, последовательностей. Все эти объекты называются в PostgreSQL - отношениями (relations), отсюда и префикс в названии столбцов "rel".
```
    SELECT relname, relkind, relnamespace, relfilenode, relowner, reltablespace FROM pg_class
    WHERE relname ~ '^(emp|man).*';
```  
Данный запрос выводит ряд столбцов:
- relname - название объекта  
- relkind - вид объекта  
    - S - последовательность  
    - r - таблица  
    - i - индекс  
    - v - представление  
- relnamespace - id схемы в которой находится данный объект  
- relfilenode - id файла содержащего данные этого объекта  
- relowner - id пользователя, которому принадлежит данный объект  
- reltablespace - id таблицы пространства где хранится данный объект  
  
Как видно, большое кол-во столбцов имеют в качестве значений идентификаторы. Для для того чтобы постоянно не писать руками скрипты с JOIN-ами соответствующих таблиц и для удобства отображения, вокруг pg_class создано большое количество представлений, например, **pg_tables**.  
3. **pg_tables** - представление для просмотра таблиц кластера баз данных, сформированное вокруг pg_class  
```
    SELECT * FROM pg_tables;
```  
4. **pg_views** - представление для просмотра всех представлений кластера баз данных, сформированное вокруг pg_class  
```
    SELECT * FROM pg_views;
```    
  
*Стоит заметить, что данные представления позволяют работать с декодированными OID (Object ID)*  
  
Сокращенные команды:  
```
    \l - список всех БД кластера
    \dn - список всех схем текущей БД
    \dt - список всех таблиц текущей БД
    \dv [reg.exp] - список всех представлений текущей БД (ищет соответствие имени представления с регулярным выражением переданным в качестве параметра)
    \di - список всех индексов текущей БД
    \ds - список всех последовательностей текущей БД
    \dtivs - вывод таблиц, индексов, представлений и последовательностей
    \d - тоже самое что и \dtivs (выводит общее описание всех объектов)
```  
У данных команд есть модификатор "+", который выполняет саму команду и добавляет к ней дополнительную информацию, например:  
```
    \dv+
```  
выведет описание представления и дополнительно к нему SQL-запрос, которым это представление образовано.  
  
Если мы хотим получить описание какого-то конкретного объекта, то необходимо выполнить команду "**\d + название_объекта**":
```
    \d manager
```  
Данная команда выводит типы данных столбцов представления или таблицы (т.е. также базовое описание объекта)  
*Команда \d не работает для схем, т.к. схема по сути своей не является объектом базы данных*  
  
Еще одна команда, которой мы можем использовать для просмотра объектов базы данных (функций) - это "**\df**". Для просмотра cистемных функций необходимо добавить в команду большую букву "S"  
```
    \df [reg.exp] - вывод всех функций текущей БД
    \dfS [reg.exp] - вывод системных функций
```  
  
Также после данных команд можно указать регулярное выражение, для того чтобы отобразить только те функции, в названии которых есть необходимые нам ключевые слова  
```
    dfS pg*size
```  
  
Для того чтобы смотреть содержание функции (что находится под капотом), нам необходимо использовать команду:  
```
    \sf схема.название_фукнции(параметры)
```  
  
```
    \sf pg_catalog.pg_database_size(oid)
```  
  
Для того чтобы вывести все команды можно выполнить команду "**\?**". Сам SQL скрипт, который выполняют под капотом данные команды можно отображать вместе с их выводом. Для это существует такая переменная (конфигурационный параметр), как **ECHO_HIDDEN**. По умолчанию она равно "off", но если ее включить, то мы сможем наблюдать скрипт, который выполнялся при вызове команды psql:  
```
    SHOW :ECHO_HIDDEN;
    \set ECHO_HIDDEN on
    \dt
```  
  
**==================> Особые типы данных <==================**  
  
OID - внутренний идентификатор объекта базы данных (Object ID) (целочисленный с автоинкрементом).  
  
Reg-типы - это семейство типов данных, которые позволяют легко ссылаться на объекты по их имени или OID. Reg-типы используются с двойным символом двоеточия "::".  
Грубо говоря, двоеточие в данном случае означает: "для объекта БД указанного слева, приведи тип данных к тому, что указано справа"  
```
    SELECT '123'::integer
    ;
```  
В данном примере строка '123' будет приведена к число 123.  
  
Reg-типы в данном контексте это условные обозначения для объектов БД (таблиц, представлений, функций и т.д.). Т.е. в ситуации, когда нам нужно узнать OID таблицы с данными, зная при этом только её название или наоборот, мы можем использовать Reg-типы, как некую хэш-фнукцию. Для каждого типа данных есть свой reg-тип - своя хэш-функция. Так например, для таблиц это reg-тип **regclass**. В данном случае, для получения OID таблицы, мы передаем в функцию  **regclass** название таблицы, а она под капотом, по названию выдает идентификатор OID. После чего мы приводим полученное значение к типу данных OID. Синтаксис будет выглядеть следующим образом:  
```
    SELECT employees::regclass::oid
    ;
```  
  
Обратное приведение из OID в название функции происходит следующим образом:  
```
    SELECT 57394::regclass::text
    ;
```  
*Символ двоеточния в данном случае - это просто синтаксический сахар, для сокращенного использования функции **CAST('42' AS integer)**, преобразующей определенный объект к другому типу данных*.  
Таким образом, хоть reg-тип и является типом данных, но для простоты запоминания его стоит рассматривать как промежуточное звено - хэш-функцию, которая преобразует тип данных из объекта указанного слева от "**::reg-тип::**" к типу данных указанному справа после данного reg-типа.  
  
Основные reg-типы и объекты БД, к которым они применяются:  
    regclass - для работы с таблицами, индексами, последовательностями и другими объектами из pg_class  
    regtype - для типов данных  
    regproc - для функций  
    regnamespace - для ссылок на схемы  
    regrole - для работы с ролями  
и т.д.  
  
Полный список данных reg-типов данных можно получить используя команду вывода типов данных "**\dT**" указав в качестве регулярного выражения "reg*"  
```
    \dT reg*
```

